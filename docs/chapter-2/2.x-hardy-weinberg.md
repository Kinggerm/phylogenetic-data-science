

# Modeling evolution: idealized populations

### Interactive Notebook
See Docs/2020-fundamentals/notebooks for work-in-progress...


### Notebook outline
- Idealized populations and Hardy Weinberg
- Hardy Weinberg as a binomial sampling problem
- Sampling error and genetic drift.

### Learning objectives

By the end of this notebook series you should:

- Know which assumptions underlie the definition of an 'idealized population'
- Understand why allele frequencies do not change in the absence of evolutionary processes.
- Be able to calculate genotype frequencies under Hardy-Weinberg equilibrium given allele frequencies at a locus.
- Understand why violations of the Hardy-Weinberg assumptions cause allele frequencies to change over generations.


### Modeling evolution

- Most modern phylogenetics is concerned with the analysis of molecular data.
- Modeling molecular evolution as a process of mutation, drift, selection, ...
- 



### Genetic variation in populations



For the examples in this notebook we are focusing on variation at a single gene (A) that has two alleles (A1 and A2) in a single population. If a new mutation arose at this gene then we could consider additional alleles, such as A3, but for simplicity we will assume only two alleles exist in the population. In fact, these types of simplifying assumptions are the topic of this notebook.



```python
import numpy as np
```

### Hardy-Weinberg Expectation

In the first cell of the figure above the population is initially not in Hardy-Weinberg equilibrium. We can tell this by looking at the genotype frequencies. There appears to be a deficit of heterozygotes. But what is the null expectation for the number of heterozygotes that should exist? Well, this is what Hardy-Weinberg can tell us. To answer that question we need to calculate the genotype frequencies after just one generation of random mating in an infinite-sized population starting with the allele frequencies that exist in the population currently.

After a single generation genotype frequencies (e.g., A1
A1, A1A2, and A2A2) will reach HW equilibrium, despite the fact that allele frequencies (e.g., A1 and A2) will not change. This expectation can be computed exactly using probability (here I will use the same genotype frequencies as in the figure above, but change the allele names to A and B, rather than A1 and A2 to make it easier to type).

```python title="initial diploid genotype frequencies"
AA = 0.3
AB = 0.0
BB = 0.7
```

Each AA parent produces two A alleles, each AB parent produces one A and one B allele, and each BB parent produces two B alleles. Based on this simple fact we can calculate the relative frequency of A and B alleles, which we label p and q. For example, p is equal to the frequency of AA homozygotes plus 1/2 the frequency of heterozygotes; q is equal to the frequency of BB homozygotes plus 1/2 the frequency of heterozygoes.

You might ask, but what if some of the diploids produced more alleles than others? Well, for that to happen would be a manifestation of either drift or selection, both of which we are assuming to be absent from this model. This is key to remember.


```python title="haploid gametes generated by diploids (given model assumptions)"
p = AA + (AB / 2)
q = BB + (AB / 2)
print(p, q)  # 0.3 0.7
```

Now that we know the frequency of alleles in the gametes we can calculate the frequency of genotypes formed in the next generation by assuming that populations are randomly mating. AA genotypes will occur with probability of sampling p twice (p * p), heterozygotes are the probability of sampling p and q (or q and p), and BB homozygotes are the probability of sampling q twice (q * q). Once again, note the importance of the assumptions underlying our idealized population for this model prediction.
<!-- HW expectation: `p**2 + 2pq + q**2 = 1` -->

```python title="Genotype frequencies of *next* generation of diploids."
newAA = p * p
newAB = 2 * p * q
newBB = q * q
print(newAA, newAB, newBB)  # 0.09 0.42 0.48999999999999994
```


```python title="Generate bar plots."
import toyplot

canvas = toyplot.Canvas(width=400, height=400)
ax0 = canvas.cartesian(grid=(0, 2, 2))
ax0.bars()
# see notebook in progress. tuba:~/Documents/2020-fundamentals/notebooks
```